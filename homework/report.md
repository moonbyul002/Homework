# 41343110 

## 作業一 Ackermann Function

# 遞迴方式

## 解題說明

Ackermann 函數是一個典型的遞迴函數，其數學定義如下： 1.​ n+1 m=0 A(m,n)= 2. A(m−1,1) m>0,n=0 3. A(m-1,A(m,n-1)) m>0,n>0

### Ackermann 函數定義如下 :
| A(m,n)                 | 條件                  |
|------------------------|----------------------|
| n + 1                  | 當 m = 0             |
| A(m-1, 1)              | 當 n = 0             |
| A(m-1, A(m, n-1))      | 其他                 |

### 解題策略

#### 題目邏輯

1.先將 Ackermann 函數的數學定義轉化為程式邏輯。

2.使用 if/else if 依條件決定不同遞迴路徑。

#### 程式流程

1.主程式讀入使用者輸入的 m、n 值

2.呼叫遞迴函式計算結果

3.輸出結果

#### 測試策略

1.從最小值測試（m=0, n=0）開始，確保基礎情況正確。

2.逐步增加 m 和 n，驗證程式正確性與堆疊使用。

3.記錄結果，與數學公式計算結果比對。

## 程式實作

以下為主要程式碼：

```cpp
#include<iostream>
using namespace std;
int ack(int m, int n) {
	if (m == 0)return n + 1;
	else if ((m > 0) && (n == 0)) return ack(m - 1, 1);
	else if ((m > 0) && (n > 0)) return ack(m - 1, ack(m, n - 1));

}
int main() {
	int A;
	int m, n;
	cout << "A(m,n)" << endl;
	cout << "輸入m值" << endl;
	cin >> m;
	cout << "輸入m值" << endl;
	cin >> n;
	A = ack(m, n);
	cout << A << endl;
	return 0;

}
```
## 效能分析
1. 時間複雜度：沒有一個多項式或指數函數可以準確描述它的時間複雜度。例如:
	ack(1, n) ≈ O(n),
	ack(2, n) ≈ O(2n),
	ack(3, n) ≈ O(2^n),
	ack(4, n) ≈ 雙重指數 (2^(2^(...n...))),ack(5, n) 幾乎無法計算，遞迴次數巨大。

2. 空間複雜度：由於是純遞迴實作，呼叫堆疊深度與遞迴層數有關。
	每次呼叫都會：
	建立一個新的「呼叫紀錄」（activation record）
	直到達成 m == 0 為止
	所以：
	空間複雜度 = 遞迴深度
	若以 A(3, n) 為例，深度約為 O(2n)
	若以 A(4, 1) 為例，可能需要數萬層遞迴，容易造成 Stack Overflow。

### 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $m$ |  輸入參數 $n$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|----------|
| 測試一   | $m = 0$      | $n = 0$   | 1 (n+1)  | 1     |
| 測試二   | $m = 1$      | $n = 3$ |    5      |5      |
| 測試三   | $m = 2$      |$n = 3$|      9    |9      |
| 測試四   | $m = 3$      |$n = 4$|     125    |125    |
| 測試五   | $m = 4$     |$n = 1$|    65533     |異常拋出   |

### 編譯與執行指令

```shell
$ g++ ack.cpp -std=c++14 -o ack (Visual Studio 2022 為C+14)
$ ack.exe
A(m,n)
輸入 m 值:
(輸入)2
輸入 n 值:
(輸入)3
(結果): 9
```

## 開發報告

### 程式目的

本程式實作 Ackermann 函數（Ackermann Function），
此函數是理論計算機科學中著名的遞迴函數之一，用來展示「遞迴深度」與「非原始遞迴（non-primitive recursive）」的概念。

### 程式設計與說明

程式使用 C++14，核心是遞迴函數 ack：
```cpp

int ack(int m, int n) {
    if (m == 0) return n + 1;
    else if (n == 0) return ack(m - 1, 1);
    else return ack(m - 1, ack(m, n - 1));
}
```
m = 0 → 回傳 n+1
n = 0 → 遞迴呼叫 ack(m-1, 1)
其他情況 → 雙層遞迴 ack(m-1, ack(m, n-1))

#### main 主程式流程：

1.輸入 m 和 n

2.呼叫 ack(m,n) 計算結果

3.輸出結果

## 開發心得與申論

#### 程式改進：

1.可加入呼叫計數器以觀察遞迴呼叫次數。

2.可加入最大遞迴層數警告，避免 Stack Overflow。

#### 實務應用：

Ackermann 函數不適合用於實務計算，主要用於理論分析。

# 非遞迴方式

## 解題說明

Ackermann 函數是一個典型的遞迴函數，其數學定義如下：
		 1.​ n+1				m=0
A(m,n)=  2. A(m−1,1)		m>0,n=0
		 3. A(m-1,A(m,n-1))	m>0,n>0
		 
### 解題策略

#### 題目邏輯

- 傳統遞迴版本每次呼叫 ack(m, n) 時，系統會自動建立新的函數堆疊。
  
- 非遞迴版本則是「手動模擬」這個堆疊，用陣列 stackM 取代系統堆疊。
  
- 每次遇到要「再呼叫自己」的情況時，改成：

- 把要計算的狀態（m 值）推入 stack

- 調整 n 的值

- 再進入下一輪迴圈模擬呼叫

#### 輸入階段

1.使用者輸入兩個整數 m、n，代表 Ackermann 函數的參數。

2.初始化堆疊

	- 宣告陣列 stackM[1000] 來模擬系統堆疊，
	
	- 並設變數 top = -1 作為堆疊頂端指標。
	
	- 將初始值 m 推入堆疊。
	
3.迴圈處理 (模擬遞迴)

	當堆疊不為空 $(top >= 0)$ 時：
	
	取出堆疊最上層的 m 值。
	
#### 測試策略

1.從最小值測試 $(m=0, n=0)$ 開始，確保基礎情況正確。

2.逐步增加 m 和 n，驗證程式正確性與堆疊使用。

3.記錄結果，與數學公式計算結果比對。

## 程式實作
以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

int ack_non_recursive(int m, int n) {
    int stackM[1000];  
    int top = -1;      

    stackM[++top] = m; 

    while (top >= 0) {
        m = stackM[top--]; 

        if (m == 0) {
            n = n + 1;
        }
        else if (n == 0) {
            n = 1;
            stackM[++top] = m - 1; 
        }
        else {
            
            stackM[++top] = m - 1;
            stackM[++top] = m;
            n = n - 1;
        }
    }

    return n;
}

int main() {
    int m, n;
    cout << "A(m,n)" << endl;
    cout << "輸入m值: ";
    cin >> m;
    cout << "輸入n值: ";
    cin >> n;

    int result = ack_non_recursive(m, n);
    cout << "Ackermann(" << m << "," << n << ") = " << result << endl;

    return 0;
}
```
## 效能分析

1. 時間複雜度：沒有封閉型時間公式，但可觀察到：

	- 當 m = 0 → 計算時間為 $O(1)$ 

	- 當 m = 1 → 時間複雜度約為 $O(n)$ 

	- 當 m = 2 → 時間約為 $O(2n)$ 

	- 當 m = 3 → 已呈指數級別增長

2. 空間複雜度：空間使用為 $O(k)$ ，其中 k 為堆疊深度。
   
## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $m$ |  輸入參數 $n$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|----------|
| 測試一   | $m = 0$      | $n = 0$   | 1 (n+1)  | 1     |
| 測試二   | $m = 1$      | $n = 3$ |    5      |5      |
| 測試三   | $m = 2$      |$n = 3$|      9    |9      |
| 測試四   | $m = 3$      |$n = 4$|     125    |125    |
| 測試五   | $m = 4$     |$n = 1$|    65533     |異常拋出   |

### 編譯與執行指令

```shell
$ g++ ack_nonrecursive.cpp -std=c++14 -o ack_nonrecursive (Visual Studio 2022 為C+14)
$ ack_nonrecursive.exe
A(m,n)
輸入m值:(輸入) 0
輸入n值:(輸入) 0
Ackermann(0,0) = 1
```

### 結論

## 開發報告

### 程式目的

本程式實作 Ackermann 函數（Ackermann Function），
此函數是理論計算機科學中著名的遞迴函數之一，用來展示「遞迴深度」與「非原始遞迴（non-primitive recursive）」的概念。

### 程式設計與說明

#### 程式運作流程

1.將初始的 m 值推入堆疊。

2.當堆疊不為空時：

	取出最上層的 m。
	
	- 若 m == 0 → 直接令 n = n + 1。
	
	- 若 n == 0 → 推入 $(m - 1)$ ，並令 n = 1。
	
	- 否則同時推入 m 與 $(m - 1)$ ，並令 n = n - 1，模擬 A(m-1, A(m, n-1)) 的過程。
	
3. 直到堆疊為空時，n 即為最終結果。
   
#### 優缺點

1. 優點：

	- 避免系統遞迴造成的 Stack Overflow。

	- 可清楚觀察每層模擬過程。

2. 限制：
   
	- 若輸入值過大，仍會造成迴圈次數過多、執行時間過長。

	- 陣列堆疊大小固定為 1000，超出將導致記憶體錯誤。

## 開發心得與申論

在學習遞迴時，Ackermann 函數是一個極具代表性的範例，它能測試電腦在深層遞迴下的極限。
透過手動推入與彈出堆疊，能清楚掌握每一步運算的對應關係。
在實作過程中，也體會到堆疊是遞迴的底層實現機制，程式的運作其實就是「由堆疊控制的反覆運算」。
## 作業一 之Powerset

## 解題說明

題目要求使用遞迴函式的方法來輸出集合S()的所有子集合。

例如: 元素設3個空間 , S =(G,C,D) , 請問 powerset(S) 會等於多少呢?
輸出: (),(G),(C),(D), (G,C), (G,D), (D,G), (G,C,D) } 

### 解題策略
這題原本要用二維陣列，但二維陣列會浪費大量記憶體空間，因此改用兩個動態記憶體配置來取代，並能改善使用者的測資輸入問題。輸出部分可以透過 for 迴圈與記憶體位置來判斷，而使用者的測資可能會有重複問題，因此可以加入 if 判斷式來提升程式的準確性。

## 程式實作

### IDE:
Microsoft Visual Studio Code C/C++

```cpp
#include <iostream>
#include <string>
using namespace std;

void pow(string A[], string s[], int i, int n, int t) {    // A[]:原集合 s[]:當前子集 i:目前處理到A[i] n:集合大小 t:當前子集大小
    if (i == n) {
        cout << "{";
        for (int j = 0; j < t; j++) {
            cout << s[j];
            if (j != t - 1) cout << ",";
        }
        cout << "}" << endl;
        return;
    }
    pow(A, s, i + 1, n, t);         // 不加入當前元素 A[i]，繼續處理下一個元素
    s[t] = A[i];                    // 加入當前元素 A[i] 到子集
    pow(A, s, i + 1, n, t + 1);     // 繼續處理下一個元素，子集大小 t 增加 1
}

int main() {
    int n;
    cout << "請輸入n個數 : ";
    cin >> n;
    string* A = new string[n];
    string* s = new string[n];
    cout << "請輸入集合元素 : ";
    for (int i = 0; i < n; i++) {
        cin >> A[i];
    }
    cout << "集合的冪集為:" << endl;
    pow(A, s, 0, n, 0);

    delete[] A;
    delete[] s;

    return 0;
}
```

## 效能分析
1. 空間複雜度：總空間複雜度 $O(n)$
2. 時間複雜度：總時間複雜度 $O(n * 2^n)$

## 測試與驗證

### 測試案例

| 測資 | 輸入參數 $n$ , 元素 | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $n = 1$ , a | () (a)       | () (a)       |
| 測試二   | $m = 2$ , a b | () (b) (a) (a,b)  | () (b) (a) (a,b)       |
| 測試三   | $m = 3$ , a b c | () (c) (b) (b,c) (a) (a,c) (a,b) (a,b,c) | () (c) (b) (b,c) (a) (a,c) (a,b) (a,b,c) |
### 編譯與執行指令

```shell
$ g++ pow.cpp -std=c++17 -o pow.exe
$ .\pow.exe
請輸入n個數 : 3
請輸入集合元素 : a b c
集合的冪集為:
{}
{c}
{b}
{b,c}
{a}
{a,c}
{a,b}
{a,b,c}
```

### 結論

1. 每多一個元素，子集數量就會變成兩倍（也就是 2ⁿ 的成長），所以當 n 很大時，程式會變得很慢、也很吃記憶體。
2. 可以加入 if 判斷式來提升程式的準確性，當使用者的測資有重複時，可以排除有一樣的子集合

## 申論及開發報告

### 選擇遞迴式回溯法的原因

1. 遞迴直觀：

   程式邏輯清楚，對每個元素只需考慮是否加入子集合的兩種情況。

2. 動態陣列：
   
   利用 new 配置陣列大小，執行時可依使用者輸入決定集合大小，不會浪費大量記憶體空間。
   
3. **優缺點**

   優點：程式結構簡潔、易於理解、不需額外資料結構
